# 算法简单复习  

  

## 1. 算法概论  



### 1.1 最大公约数的分析

**欧几里得算法：**  

`gcd(m,n) = gcd(n, m mod n) iteratively while n != 0`

`gcd(m,0) = m`

**连续整数检测法：**

比较麻烦，先看看较小的能不能当gcd，不行的话，每次减1再判断。

### 1.2 算法常识

**伪代码的介绍：**

*自然语言和编程语言相结合的产物*

*精确又简明*

*本课中：忽略变量的声明；用缩进来表示`if`和`while`等语句的范围；使用&larr;表示赋值。*

**算法的特点：**

*输入、输出、确定、有穷、可行*

**算法的定义：**

在有限的时间内，对问题求解的一个清晰的指令序列。

本章**思考题**：

证明欧几里得算法对每一对正整数都成立。



## 2. 算法分析基础



### 2.1 增长速度表

$1$ $<$ $log_2{n}$ $<$ $n$ $<$ $nlog_2{n}$ $<$ $n^2$ $<$ $n^3$ $<$ $2^n$ $<$ $n!$ 

### 2.2 算法分析框架概述

*时间复杂度是通过计算基本操作（basic operations）得到的*

*时空复杂度是关于输入规模（n）的函数*

### 2.3 渐进复杂度

设要分析的对象是$T(n)$，当
$$
lim_{n \to \infty}\frac{T(n) - t(n)}{T(n)} \to 0
$$
$t(n)$就是$T(n)$的渐进形式 *(asymptotic state)*

$t(n)$也叫作算法A的 $n \to \infty $ 渐进复杂度

- $t(n)$只考虑$T(n)$的 *leading term*
- 忽略常系数

---

| 符号           | 意义                                      | 例子                                                         |
| -------------- | ----------------------------------------- | ------------------------------------------------------------ |
| $O(g(n))$      | 增长得不比 $g$ 快的一系列函数的集合       | $10n^2 \in O(n^2)$, $10n^2 + 2n \in O(n^2)$ , $100n + 5 \in O(n^2)$ , $5n + 20 \in O(n)$ |
| $\Omega(g(n))$ | 增长得至少和 $g$ 一样快的一系列函数的集合 | $10n^2 \in \Omega(n^2)$ , $10n^2 + 2n \in \Omega(n^2)$ , $10n^3 \in \Omega(n^2)$ |
| $\Theta(g(n))$ | 增长得和 $g$ 一样快的一系列函数的集合     | $10n^2 \in \Theta(n^2)$ , $an^2 + bn +c \in \Theta(n^2)$ $a>0$ ,  $\frac{(n)(n-1)}{2} \in \Theta(n^2)$ , $n^2 + \lg{n} \in \Theta(n^2)$ |

---

**渐进表达式的运算性质：**

*反身性、传递性、互对称性、对称性、大O加法乘法结合律*

---

**用极限来分析：**

求
$$
lim_{n \to \infty}{\frac{T(n)}{g(n)}}
$$
结果有三种：

$$
 \left\{ \begin{aligned} 0, &T(n)<g(n) \\ c>0, &T(n) = g(n) \\ \infty, &T(n)>g(n) \end{aligned} \right. ​
$$
​	case1&2：$T(n) \in O(g(n))$

​	case2     ：$T(n) \in \Theta(g(n))$

​	case2&3：$T(n) \in \Omega(g(n))$

算不出来可以用**洛必达法则**

---

**一些注意事项：**

所有对数函数都属于$\Theta(\log{n})$

所有多项式都属于$\Theta(n^k)$，$k$是多项式的次数

指数函数根据底数的不同，增长的速率不同。

### 2.4 常见的求和公式

$$
\sum_{i=l}^{u}(a^i \pm b^i) = \sum_{i=l}^{u}a^i \pm \sum_{i=l}^{u}b^i
$$

$$
\sum_{i=l}^{u}1 = u - l + 1
$$


$$
\sum_{i=0}^{n}i = \frac{n^2}{2} \in \Theta(n^2)
$$

### 2.5 实例

*汉诺塔，递归解法*

```c
void hanoi(int n, int a, int b, int c){
	if(n>0)
		{
			hanoi(n-1,a,c,b);
			move(a,b);
			hanoi(n-1,b,a,c);
	}
}
```

其基本操作数为：

$C(n) = 2C(n-1) + 1 = 2^n-1$ 

---

*数十进制数的二进制形式有几位数字*

```pseudocode
ALGORITHM BinRec(n)
	//Input: A positive decimal integer n
	//Output: The number of bin. digits in n's bin representation
	if n=1 return 1
	else return BinRec(floor(n/2)+1)
```

基本操作：$$+1$$的动作

解决这种递归的方法：令$n=2^k$，但是这种做法似乎忽略了许多个n的值。*Smoothness Rule*告诉我们这是ok的。

易知$A(n) = \log_2{n} = \Theta(\log{n})$

## 3. 暴力法

### 3.1 暴力法为什么要讲？

它给解决问题提供了一个下界。

对于这些问题，都可以用暴力法：

排序 - 选择排序、冒泡排序

穷举 - （哈密顿图）TSP问题、背包问题、分派工作：NP-Hard问题

## 4. 递归法

### 4.1 常见的递归法求解的问题

阶乘

斐波那契

汉诺塔问题

排列问题 

### 4.2 递归解法的类型

- Decrease-by-one

  $T(n) = T(n-1) + f(n)$

  ---

- Decrease-by-a-constant-factor

  $T(n) = aT(\frac{n}{b}) + f(n)$

  

  ***The Master Theorem***

  $T(n)=aT(\frac{n}{b})+f(n)$, where $f(n) \in \Theta(n^k)$

  a. $a<b^k $, then $T(n) \in \Theta(n^k)$

  b. $a=b^k $, then $T(n) \in \Theta(n^k\log{n})$

  c. $a>b^k $, then $T(n) \in \Theta(n^{\log_b{a}})$



## 5. 分治法

### 5.1 怎样的问题适合分治法

原始问题的解可以规模均衡地分成相同类型的互相独立的最小问题地解，将后者做合并得到原始问题的解

### 5.2 一个常规的分治法

假设：*把一个规模为$n$的问题，分成$a$个规模为$\frac{n}{b}$的子问题。$a$是每次分叉要解决的问题个数（分叉数）*

则可以得到
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ aT(\frac{n}{b})+f(n), &n>1 \end{aligned} \right.
$$
$f(n)$是我们在分叉和合并的时候需要花的时间。

### 5.3 大数相乘问题

给两个n位数字，做乘法。

- 蛮力法带来$n^2$的时间复杂度

---

*一次分治算法的尝试*

分治法解决，将两数这样分解：
$$
X = A * 10^{\frac{n}{2}} + B
$$

$$
Y = C*10^{\frac{n}{2}}+D
$$

其中$A,B,C,D$都是$\frac{n}{2}$位数字

那么有：
$$
X*Y = A*C*10^n +(A*D+B*C)*10^\frac{n}{2}+B*D
$$
因为$*10^n$或者$*10^\frac{n}{2}$都不能算作和n的规模有关，只能算作多加了几个零，或者最后列竖式的时候左移了几个位置。所以考虑这个子问题规模的时候，只用看到把**1**对$n$位数相乘，变成了**4**对$\frac{n}{2}$位数相乘的问题。每对需要的时间复杂度是$O(n)$。

得出了
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 4T(\frac{n}{2})+O(n), &n>1 \end{aligned} \right.
$$
之后，利用`4.2`中的公式，可以很快得到，

$T(n) \in \Theta(n^{\log_2{4}})$

即$\Theta(n^2)$。

***并没有啥改进啊。***

---

*Karatsuba算法（卡拉楚巴算法）*

分成


$$
X = A * 10^{\frac{n}{2}} + B
$$

$$
Y = C*10^{\frac{n}{2}}+D
$$

$$
X*Y = A*C*10^n +(A*D+B*C)*10^\frac{n}{2}+B*D
$$

之后，

观察$(A*D+B*C)$这一项，发现可以由
$$
(A+B)*(C+D) - A*C-B*D
$$
得到。那么上式可以这样变换一下：

$X*Y = A*C*10^n +[(A+B)*(C+D) - A*C-B*D]*10^\frac{n}{2}+B*D$

发现只用计算

$A*C, (A+B)*(C+D), B*D$这三项就可以得到。直接把四次惩罚变成了三次乘法。

抓大放小，可以得到：

$T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 3T(\frac{n}{2})+O(n), &n>1 \end{aligned} \right.$

这样的话，时间复杂度是

$T(n) \in \Theta(n^{\log_2{3}})$（这里也可以作$n = 2^k$的变换）

即$\Theta(n^{1.585})$。

---

*快速傅里叶变换算法*

太难了，略。



### 5.4 矩阵相乘

蛮力法，要用$O(n^3)$才能解决（n是矩阵的阶数）。

---

一次分治算法的尝试：

将最终结果分成四部分，

得到：
$$
\left[ \matrix{  C_{11} & C_{12}\\ C_{21} & C_{22}} \right] = \left[ \matrix{  A_{11} & A_{12}\\ A_{21} & A_{22}} \right]\left[ \matrix{  B_{11} & B_{12}\\ B_{21} & B_{22}} \right]
$$
即
$$
\left[ \matrix{  A_{11}B_{11} + A_{12}B_{21} &A_{11}B_{12} + A_{12}B_{22}\\ A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}} \right]
$$
易知这样的分治，得到的还是
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 8T(\frac{n}{2})+O(n^2), &n>1 \end{aligned} \right.
$$
用公式得出$T(n) \in \Theta(n^{\log_2{8}})$，***没有甚么区别啊。***

---

*史特拉森（Strassen）演算法：*


$$
\left[ \matrix{  C_{11} & C_{12}\\ C_{21} & C_{22}} \right] = \left[ \matrix{  A_{11} & A_{12}\\ A_{21} & A_{22}} \right]\left[ \matrix{  B_{11} & B_{12}\\ B_{21} & B_{22}} \right]
$$
设每一个$M$都是$\frac{n}{2}$阶的矩阵线性变换得到的，那么原始可以写成：（$M$具体可以在*PPT-Chap5*的第13页找到）
$$
\left[ \matrix{  M_{5}+M_{4}-M_{2}+M_{6}&M_{1}+M_{2}\\ M_{3}+M_{4} & M_{5}+M_{1}-M_{3}-M_{7}} \right]
$$
可以得到：
$$
M(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 7M(\frac{n}{2}), &n>1 \end{aligned} \right.
$$
用公式得出$T(n) \in \Theta(n^{\log_2{7}}) = \Theta(n^{2.807})$

**注意事项：**

如果阶数并不是2的指数，矩阵可以通过填0来得到。

一般来说，当这个算法跨越了某个交点之后，就可以转换成暴力法了。



### 5.5 二分搜索

问题描述：在一个非降序的数组中查找元素，存在返回位置，不存在返回-1.

----

*迭代求法*

```pseudocode
ALGO BinSearchIt(A[0...n-1], K)
l = 0; r = n-1
while l<=r do
	m = floor((l+r)/2)
	if K = A[m] return m
	else if K < A[m] r = m - 1
	else r = m + 1
return -1
```

---

*递归求法*

```pseudocode
ALGO BinSearchRec(A[0...n-1], K, l, r)
if l > r return -1
else 
	m = floor((l+r)/2)
	if K = A[m] return m
	else if K < A[m] return BinSearchRec(A[0...n-1], K, l, m - 1)
	else return BinSearchRec(A[0...n-1], K, m + 1, r)
return -1
```

---

分析：

最坏情况下，$\Theta(\log{n})$；最好情况下，$O(1)$，一次找到。

==一般情况下==，要分析平均时间。



