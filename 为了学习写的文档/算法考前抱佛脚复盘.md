# 算法简单复习  

  

## 1. 算法概论  



### 1.1 最大公约数的分析

**欧几里得算法：**  

`gcd(m,n) = gcd(n, m mod n) iteratively while n != 0`

`gcd(m,0) = m`

**连续整数检测法：**

比较麻烦，先看看较小的能不能当gcd，不行的话，每次减1再判断。

### 1.2 算法常识

**伪代码的介绍：**

*自然语言和编程语言相结合的产物*

*精确又简明*

*本课中：忽略变量的声明；用缩进来表示`if`和`while`等语句的范围；使用&larr;表示赋值。*

**算法的特点：**

*输入、输出、确定、有穷、可行*

**算法的定义：**

在有限的时间内，对问题求解的一个清晰的指令序列。

本章**思考题**：

证明欧几里得算法对每一对正整数都成立。



## 2. 算法分析基础



### 2.1 增长速度表

$1$ $<$ $log_2{n}$ $<$ $n$ $<$ $nlog_2{n}$ $<$ $n^2$ $<$ $n^3$ $<$ $2^n$ $<$ $n!$ 

### 2.2 算法分析框架概述

*时间复杂度是通过计算基本操作（basic operations）得到的*

*时空复杂度是关于输入规模（n）的函数*

### 2.3 渐进复杂度

设要分析的对象是$T(n)$，当
$$
lim_{n \to \infty}\frac{T(n) - t(n)}{T(n)} \to 0
$$
$t(n)$就是$T(n)$的渐进形式 *(asymptotic state)*

$t(n)$也叫作算法A的 $n \to \infty $ 渐进复杂度

- $t(n)$只考虑$T(n)$的 *leading term*
- 忽略常系数

---

| 符号           | 意义                                      | 例子                                                         |
| -------------- | ----------------------------------------- | ------------------------------------------------------------ |
| $O(g(n))$      | 增长得不比 $g$ 快的一系列函数的集合       | $10n^2 \in O(n^2)$, $10n^2 + 2n \in O(n^2)$ , $100n + 5 \in O(n^2)$ , $5n + 20 \in O(n)$ |
| $\Omega(g(n))$ | 增长得至少和 $g$ 一样快的一系列函数的集合 | $10n^2 \in \Omega(n^2)$ , $10n^2 + 2n \in \Omega(n^2)$ , $10n^3 \in \Omega(n^2)$ |
| $\Theta(g(n))$ | 增长得和 $g$ 一样快的一系列函数的集合     | $10n^2 \in \Theta(n^2)$ , $an^2 + bn +c \in \Theta(n^2)$ $a>0$ ,  $\frac{(n)(n-1)}{2} \in \Theta(n^2)$ , $n^2 + \lg{n} \in \Theta(n^2)$ |

---

**渐进表达式的运算性质：**

*反身性、传递性、互对称性、对称性、大O加法乘法结合律*

---

**用极限来分析：**

求
$$
lim_{n \to \infty}{\frac{T(n)}{g(n)}}
$$
结果有三种：

$$
 \left\{ \begin{aligned} 0, &T(n)<g(n) \\ c>0, &T(n) = g(n) \\ \infty, &T(n)>g(n) \end{aligned} \right. ​
$$
​	case1&2：$T(n) \in O(g(n))$

​	case2     ：$T(n) \in \Theta(g(n))$

​	case2&3：$T(n) \in \Omega(g(n))$

算不出来可以用**洛必达法则**

---

**一些注意事项：**

所有对数函数都属于$\Theta(\log{n})$

所有多项式都属于$\Theta(n^k)$，$k$是多项式的次数

指数函数根据底数的不同，增长的速率不同。

### 2.4 常见的求和公式

$$
\sum_{i=l}^{u}(a^i \pm b^i) = \sum_{i=l}^{u}a^i \pm \sum_{i=l}^{u}b^i
$$

$$
\sum_{i=l}^{u}1 = u - l + 1
$$


$$
\sum_{i=0}^{n}i = \frac{n^2}{2} \in \Theta(n^2)
$$

### 2.5 实例

*汉诺塔，递归解法*

```c
void hanoi(int n, int a, int b, int c){
	if(n>0)
		{
			hanoi(n-1,a,c,b);
			move(a,b);
			hanoi(n-1,b,a,c);
	}
}
```

其基本操作数为：

$C(n) = 2C(n-1) + 1 = 2^n-1$ 

---

*数十进制数的二进制形式有几位数字*

```pseudocode
ALGORITHM BinRec(n)
	//Input: A positive decimal integer n
	//Output: The number of bin. digits in n's bin representation
	if n==1 return 1
	else return BinRec(floor(n/2)+1)
```

基本操作：$$+1$$的动作

解决这种递归的方法：令$n=2^k$，但是这种做法似乎忽略了许多个n的值。*Smoothness Rule*告诉我们这是ok的。

易知$A(n) = \log_2{n} = \Theta(\log{n})$

## 3. 暴力法

### 3.1 暴力法为什么要讲？

它给解决问题提供了一个下界。

对于这些问题，都可以用暴力法：

排序 - 选择排序、冒泡排序

穷举 - （哈密顿图）TSP问题、背包问题、分派工作：NP-Hard问题

## 4. 递归法

### 4.1 常见的递归法求解的问题

阶乘

斐波那契

汉诺塔问题

排列问题 

### 4.2 递归解法的类型

- Decrease-by-one

  $T(n) = T(n-1) + f(n)$

  ---

- Decrease-by-a-constant-factor

  $T(n) = aT(\frac{n}{b}) + f(n)$

  

  ***The Master Theorem***

  $T(n)=aT(\frac{n}{b})+f(n)$, where $f(n) \in \Theta(n^k)$

  a. $a<b^k $, then $T(n) \in \Theta(n^k)$

  b. $a=b^k $, then $T(n) \in \Theta(n^k\log{n})$

  c. $a>b^k $, then $T(n) \in \Theta(n^{\log_b{a}})$



## 5. 分治法

### 5.1 怎样的问题适合分治法

原始问题的解可以规模均衡地分成相同类型的互相独立的最小问题地解，将后者做合并得到原始问题的解

### 5.2 一个常规的分治法

假设：*把一个规模为$n$的问题，分成$a$个规模为$\frac{n}{b}$的子问题。$a$是每次分叉要解决的问题个数（分叉数）*

则可以得到
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ aT(\frac{n}{b})+f(n), &n>1 \end{aligned} \right.
$$
$f(n)$是我们在分叉和合并的时候需要花的时间。

### 5.3 大数相乘问题

给两个n位数字，做乘法。

- 蛮力法带来$n^2$的时间复杂度

---

*一次分治算法的尝试*

分治法解决，将两数这样分解：
$$
X = A * 10^{\frac{n}{2}} + B
$$

$$
Y = C*10^{\frac{n}{2}}+D
$$

其中$A,B,C,D$都是$\frac{n}{2}$位数字

那么有：
$$
X*Y = A*C*10^n +(A*D+B*C)*10^\frac{n}{2}+B*D
$$
因为$*10^n$或者$*10^\frac{n}{2}$都不能算作和n的规模有关，只能算作多加了几个零，或者最后列竖式的时候左移了几个位置。所以考虑这个子问题规模的时候，只用看到把**1**对$n$位数相乘，变成了**4**对$\frac{n}{2}$位数相乘的问题。每对需要的时间复杂度是$O(n)$。

得出了
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 4T(\frac{n}{2})+O(n), &n>1 \end{aligned} \right.
$$
之后，利用`4.2`中的公式，可以很快得到，

$T(n) \in \Theta(n^{\log_2{4}})$

即$\Theta(n^2)$。

***并没有啥改进啊。***

---

*Karatsuba算法（卡拉楚巴算法）*

分成


$$
X = A * 10^{\frac{n}{2}} + B
$$

$$
Y = C*10^{\frac{n}{2}}+D
$$

$$
X*Y = A*C*10^n +(A*D+B*C)*10^\frac{n}{2}+B*D
$$

之后，

观察$(A*D+B*C)$这一项，发现可以由
$$
(A+B)*(C+D) - A*C-B*D
$$
得到。那么上式可以这样变换一下：

$X*Y = A*C*10^n +[(A+B)*(C+D) - A*C-B*D]*10^\frac{n}{2}+B*D$

发现只用计算

$A*C, (A+B)*(C+D), B*D$这三项就可以得到。直接把四次惩罚变成了三次乘法。

抓大放小，可以得到：

$T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 3T(\frac{n}{2})+O(n), &n>1 \end{aligned} \right.$

这样的话，时间复杂度是

$T(n) \in \Theta(n^{\log_2{3}})$（这里也可以作$n = 2^k$的变换）

即$\Theta(n^{1.585})$。

---

*快速傅里叶变换算法*

太难了，略。



### 5.4 矩阵相乘

蛮力法，要用$O(n^3)$才能解决（n是矩阵的阶数）。

---

一次分治算法的尝试：

将最终结果分成四部分，

得到：
$$
\left[ \matrix{  C_{11} & C_{12}\\ C_{21} & C_{22}} \right] = \left[ \matrix{  A_{11} & A_{12}\\ A_{21} & A_{22}} \right]\left[ \matrix{  B_{11} & B_{12}\\ B_{21} & B_{22}} \right]
$$
即
$$
\left[ \matrix{  A_{11}B_{11} + A_{12}B_{21} &A_{11}B_{12} + A_{12}B_{22}\\ A_{21}B_{11} + A_{22}B_{21} & A_{21}B_{12} + A_{22}B_{22}} \right]
$$
易知这样的分治，得到的还是
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 8T(\frac{n}{2})+O(n^2), &n>1 \end{aligned} \right.
$$
用公式得出$T(n) \in \Theta(n^{\log_2{8}})$，***没有甚么区别啊。***

---

*史特拉森（Strassen）演算法：*


$$
\left[ \matrix{  C_{11} & C_{12}\\ C_{21} & C_{22}} \right] = \left[ \matrix{  A_{11} & A_{12}\\ A_{21} & A_{22}} \right]\left[ \matrix{  B_{11} & B_{12}\\ B_{21} & B_{22}} \right]
$$
设每一个$M$都是$\frac{n}{2}$阶的矩阵线性变换得到的，那么原始可以写成：（$M$具体可以在*PPT-Chap5*的第13页找到）
$$
\left[ \matrix{  M_{5}+M_{4}-M_{2}+M_{6}&M_{1}+M_{2}\\ M_{3}+M_{4} & M_{5}+M_{1}-M_{3}-M_{7}} \right]
$$
可以得到：
$$
M(n) = \left\{ \begin{aligned} O(1), & n=1 \\ 7M(\frac{n}{2}), &n>1 \end{aligned} \right.
$$
用公式得出$T(n) \in \Theta(n^{\log_2{7}}) = \Theta(n^{2.807})$

**注意事项：**

如果阶数并不是2的指数，矩阵可以通过填0来得到。

一般来说，当这个算法跨越了某个交点之后，就可以转换成暴力法了。



### 5.5 二分搜索和平均查找时间

问题描述：在一个非降序的数组中查找元素，存在返回位置，不存在返回-1.

----

*迭代求法*

```pseudocode
ALGO BinSearchIt(A[0...n-1], K)
l = 0; r = n-1
while l<=r do
	m = floor((l+r)/2)
	if K == A[m] return m
	else if K < A[m] r = m - 1
	else r = m + 1
return -1
```

---

*递归求法*

```pseudocode
ALGO BinSearchRec(A[0...n-1], K, l, r)
if l > r return -1
else 
	m = floor((l+r)/2)
	if K == A[m] return m
	else if K < A[m] return BinSearchRec(A[0...n-1], K, l, m - 1)
	else return BinSearchRec(A[0...n-1], K, m + 1, r)
return -1
```

---

分析：

最坏情况下，$\Theta(\log{n})$；最好情况下，$O(1)$，一次找到。

一般情况下，要分析平均时间。（图片在*PPT-Chap5*第23页）

$$
A(n) = \frac{1}{n} \sum_{i=1}^{k}i*2^{i-1}\approx \log{(n+1)}-1
$$
这个式子就是计算一棵搜索树里将每个节点寻找的次数加一起，再除以总数，得到平均值。

- 二元比较树的表示方法，分析方法
- 内结点、外结点代表啥

逐个查找法，平均查找时间这样算：

<img src=".\images\线性查找平均查找时间.png" alt="alt" style="zoom:50%;" />

这里的P是查找某个元素的概率。一般来说，如果找每个元素的概率都相同，应该是$\frac{1}{n}$。

### 5.6 归并排序

```pseudocode
ALGO MergeSort(A[0...n-1])
//Input: 
//Output: ~non-decreasing order~
if n>1
	copy A[0...floor(n/2)-1] to B[0...floor(n/2)-1]
	copy A[floor(n/2)...n-1] to C[0...ceiling(n/2)-1]
	MergeSort(B[0...floor(n/2)-1])
	MergeSort(C[0...ceiling(n/2)-1])
	Merge(B,C,A)
```

```pseudocode
ALGO Merge(B[0...p-1],C[0...q-1],A[0...p+q-1])
//将两个已排好序的数组合并为一个数组
//Input:
//Output:A[0...p+q-1]
i = 0; j = 0; k = 0;
while i < p and j < q do
	if B[i] <= C[j]
		A[k] = B[i]; i = i + 1
	else A[k] = C[j]; j = j + 1
	k = k + 1
if i == p
	copy C[j...q-1] to A[k...p+q-1]
else copy B[i...p-1] to A[k...p+q-1]
```

可以分析一下最深处的一次递归，是把两个数字排好序，放到一个大小为`2`的数组中。

时间复杂度比较好分析：
$$
\left\{ \begin{aligned} C(n) = 2C(n/2)+C_{merge}(n) \ & \textit{, n>1}  \\ C(n) = 0 & \textit{, n=1}\end{aligned} \right.
$$

$$
\textit{where } C_{merge}(n) = n-1
$$

这里的$C_{merge}$就是上面的`Merge(,,)`做的事情。代入之前的公式（$k=1, a = 2,b=2$），易得：
$$
C(n) \in \Theta(n*\log{n})
$$

### 5.7 快速排序

概括一下快速排序的中心思想：所谓分类（Partition）就是把一个数组，分成大于某个数和小于某个数的两个子数组。这时，“某个数”的位置已经被排好。再递归对某个数前后的数组进行Divide操作，最后的大数组自动排好，不用合并。

从左到右扫描时，用`i`索引。遇到小于等于基准元素的，自增跳过。遇到第一个大于基准元素的就停下来。

从右到左扫描时，用`j`索引。和上面的刚好相反。

此时，有两种情况导致扫描停止：

`case 1`

`i,j`没有相遇，也即`i<j`

交换元素

`case 2`

`i,j`相遇也即`i=>j`

本轮划分扫描结束，将基准点放在它应该处的位置上（这里应该是将基准点元素和`a[j]`作了交换）：`a[j] = pivot`，返回基准点的位置：`return j`

在大递归调用中，再把基准点坐标作为中点，进行递归的划分。

```pseudocode
ALGO QuickSort(A[l...r])
//Input:
//Output: 非降序排列的子数组。
if l<r
	s = Partition(A[l...r])
	QuickSort(A[l...s-1])
	QuickSort(A[s+1...r])
```

```pseudocode
ALGO Partition(A[l...r])
//Input：
//Output: pivot's location
i = l + 1; j = r ;
pivot = A[l]
while true do
	while A[i] < pivot
		i = i + 1
	while A[j] > pivot
		j = j -1
	if i >= j break
	Swap(A[i], A[j])
a[l] = a[j]
a[j] = pivot
return j
```

对快排算法的分析：

一次划分（Partition）需要的比较次数：$n+1$或者$n$。前者是两指针已经相遇并穿过了对方，后者是刚好相遇。

在完美情况下，我们选择的基准每次都可以被安插在这一段的中间：
$$
\left\{ \begin{aligned} C(n) = 2C(n/2)+\Theta(n) \ & \textit{, n>1}  \\ C(n) = 0 & \textit{, n=1}\end{aligned} \right.
$$
代公式（或者也可以用$n=2^k$替换）得到：
$$
C(n) \in \Theta(n*\log{n})
$$
在最坏情况下，这是一个倒序数组。
$$
C(n) =  C(n-1) + \Theta(n)
$$
易知结果是
$$
C(n) \in \Theta(n^2)
$$
这里是这样算的：
$$
C = (n+1) + n + \textit{ ... } + 3 = (n+1)*(n+2)/2 - 3 = \Theta(n^2)
$$
以左值为基准，`i`停在左值旁边的第一个元素`A[1]`，`j`一直滑到`A[0]`，一共`n+1`次比较。比到`n=2`。

随机划分的情况下，据说*《算法导论》第七章* 有证明，可以得到是：
$$
C(n) \in \Theta(n*\log{n})
$$

### 5.8 棋盘覆盖问题

问题描述：有点长，可以看*PPT-Chap5-Page48*。

分治策略：

把$2^k*2^k$的棋盘分成四个$2^{k-1}*2^{k-1}$的小小棋盘。在**没有特殊方格**的三个小棋盘的汇合处，用一个L型骨牌覆盖。再递归进行分割。这时被L型骨牌覆盖的部分，当作特殊方格处理。

分析：
$$
T(n) = \left\{ \begin{aligned} O(1), & k=0 \\ 4T(k-1)+O(1), &k>0 \end{aligned} \right.
$$

$$
T(n) = O(4^k)
$$

### 5.9 分治法总结

分治法的时间效率满足：$T(n) = aT(\frac{n}{b})+f(n)$

归并排序在任何情况下时间效率都是：$\Theta(n\log{n})$。

快排的最快时间效率和最差时间效率。

折半查找的时间效率。

`n`位大整数乘法的最优时间效率。

`Strassen`算法也是分治算法，它的时间效率...



## 6. 减治法

### 6.1 啥是减治法

如果一个问题“一个实例”的解和它的“较小实例”的解存在某种关系，就可以用减治技术。***感觉还是不太懂啊。***

### 6.2 减治法的类型

**减常量**

插入排序（较小实例：`A[0...n-2]`，问题实例:`A[0...n-1]`）、拓扑排序（大有向图总是通过小有向图在孤立节点里找到一个节点完成的）。

**减常数因子**

二分搜索、假硬币问题、俄罗斯农民乘法问题

**减可变因子**

欧几里得算法求`gcd`

### 6.3 插入排序

```pseudocode
ALGO InsertionSort(A[0...n-1])
for i = 1 to n - 1 do
	v = A[i]
	j = i - 1
	while j >= 0 and A[j] > v do
		A[j+1] = A[j]
		j = j - 1
	A[j+1] = v
```

分析：
$$
C_{worst} (n) = \sum_{i=1}^{n-1}\sum_{j=0}^{i-1}1 = \sum_{i=1}^{n-1}i = \frac{(n-1)n}{2}\in\Theta(n^2)
$$

$$
C_{best} (n) =  \sum_{i=1}^{n-1}1 = n-1\in\Theta(n)
$$

$$
C_{ave} (n) \approx \frac{n^2}{4} \in\Theta(n^2)
$$



### 6.4 拓扑排序

*DFS方法*

基本思想就是，从第一个结点开始，一直搜索直到一个没有任何出度或所有出边都被找过的结点，入栈。

这一段[来自力扣的代码]([课程表 II - 课程表 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/))写得相当清楚：

```c++
class Solution {
private:
    // 存储有向图
    vector<vector<int>> edges;
    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
    vector<int> visited;
    // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶
    vector<int> result;
    // 判断有向图中是否有环
    bool valid = true;

public:
    void dfs(int u) {
        // 将节点标记为「搜索中」
        visited[u] = 1;
        // 搜索其相邻节点
        // 只要发现有环，立刻停止搜索
        for (int v: edges[u]) {
            // 如果「未搜索」那么搜索相邻节点
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            }
            // 如果「搜索中」说明找到了环
            else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }
        // 将节点标记为「已完成」
        visited[u] = 2;
        // 将节点入栈
        result.push_back(u);
    }

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visited.resize(numCourses);
        for (const auto& info: prerequisites) {
            edges[info[1]].push_back(info[0]);
        }
        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
        for (int i = 0; i < numCourses && valid; ++i) {
            if (!visited[i]) {
                dfs(i);
            }
        }
        if (!valid) {
            return {};
        }
        // 如果没有环，那么就有拓扑排序
        // 注意下标 0 为栈底，因此需要将数组反序输出
        reverse(result.begin(), result.end());
        return result;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

分析（**图的深度优先搜索时间复杂度**）：

$O(E+V)$

`V`来自每个点进行遍历的外循环，`E`来自每个点的所有出边。

*删源结点法（Source Removal Method）*

每次寻找入度为`0`的结点，加入结果，从图中删除。重复（减治法）。

### 6.5 二分查找的递归形式

见 5.5.

### 6.6 假硬币问题

问题描述：`n`个硬币，一个是假的，用天平鉴别出假的。

*减常数因子：每次对半砍*

开始之前，如果`n`是奇数，每次留下一个，如果数量为$\frac{n-1}{2}$的两堆硬币一样重，说明拿出的那个是假币，问题就解决了。否则将剩下的硬币分成两堆去比较重量。

分析：
$$
T(n) = \left\{ \begin{aligned} 0, & n=1 \\ T(\frac{n}{2}) + 1, &n>1 \end{aligned} \right.
$$
可知：
$$
T(n) \in O(\log_2{n})
$$
*减常数因子：每次分成三堆*

比较两个n/3的，剩下的当第三堆。分析：
$$
T(n) = \left\{ \begin{aligned} 0, & n=1 \\ T(\frac{n}{3}) + 1, &n>1 \end{aligned} \right.
$$
可知：
$$
T(n) \in O(\log_3{n})
$$

### 6.7 俄罗斯农民乘法问题

问题描述：想要获得`n*m`，将式子变为：
$$
\left\{\begin{aligned} n*m = \frac{n}{2}*2m &\textit{, n is even}\\ n*m = \frac{n-1}{2}*2m+m&\textit{, n is odd}\end{aligned} \right.
$$

```pseudocode
ALGO RPM(m,n)
res = 0;
while n > 0 do
	if n is odd
		res = res + m;
	m = m * 2;
	n = n / 2;
return res
```

分析：（在[sof上](https://stackoverflow.com/questions/28888068/time-complexity-of-russian-peasant-multiplication-algorithm)有详细到比特操作的复杂度分析，此处按照减治法的分析方法简化一下：设`n`为小值）
$$
T(n) = \left\{ \begin{aligned} O(1), & n=1 \\ T(\frac{n}{2}) + O(1), &n>1 \end{aligned} \right.
$$
可知：
$$
T(n) \in O(\log_2{n})
$$

### 6.8 减治法回顾

其实就是上面几条，都不多。注意插入排序和拓扑排序。



## 7 变治法

