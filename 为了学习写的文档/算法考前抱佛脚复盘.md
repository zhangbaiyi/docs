# 算法复盘  

  

## 1. 算法概论  



### 1.1 最大公约数的分析

**欧几里得算法：**  

`gcd(m,n) = gcd(n, m mod n) iteratively while n != 0`

`gcd(m,0) = m`

**连续整数检测法：**

比较麻烦，先看看较小的能不能当gcd，不行的话，每次减1再判断。



### 1.2 算法常识

**伪代码的介绍：**

*自然语言和编程语言相结合的产物*

*精确又简明*

*本课中：忽略变量的声明；用缩进来表示`if`和`while`等语句的范围；使用&larr;表示赋值。*

**算法的特点：**

*输入、输出、确定、有穷、可行*

**算法的定义：**

在有限的时间内，对问题求解的一个清晰的指令序列。

本章**思考题**：

证明欧几里得算法对每一对正整数都成立。



## 2. 算法分析基础



### 2.1 增长速度表

$1$ $<$ $log_2{n}$ $<$ $n$ $<$ $nlog_2{n}$ $<$ $n^2$ $<$ $n^3$ $<$ $2^n$ $<$ $n!$ 

### 2.2 算法分析框架概述

*时间复杂度是通过计算基本操作（basic operations）得到的*

*时空复杂度是关于输入规模（n）的函数*

### 2.3 渐进复杂度

设要分析的对象是$T(n)$，当
$$
lim_{n \to \infty}\frac{T(n) - t(n)}{T(n)} \to 0
$$
$t(n)$就是$T(n)$的渐进形式 *(asymptotic state)*

$t(n)$也叫作算法A的 $n \to \infty $ 渐进复杂度

- $t(n)$只考虑$T(n)$的 *leading term*
- 忽略常系数

| 符号           | 意义                                      | 例子                                                         |
| -------------- | ----------------------------------------- | ------------------------------------------------------------ |
| $O(g(n))$      | 增长得不比 $g$ 快的一系列函数的集合       | $10n^2 \in O(n^2)$, $10n^2 + 2n \in O(n^2)$ , $100n + 5 \in O(n^2)$ , $5n + 20 \in O(n)$ |
| $\Omega(g(n))$ | 增长得至少和 $g$ 一样快的一系列函数的集合 | $10n^2 \in \Omega(n^2)$ , $10n^2 + 2n \in \Omega(n^2)$ , $10n^3 \in \Omega(n^2)$ |
| $\Theta(g(n))$ | 增长得和 $g$ 一样快的一系列函数的集合     | $10n^2 \in \Theta(n^2)$ , $an^2 + bn +c \in \Theta(n^2)$ $a>0$ ,  $\frac{(n)(n-1)}{2} \in \Theta(n^2)$ , $n^2 + \lg{n} \in \Theta(n^2)$ |

**渐进表达式的运算性质：**

*反身性、传递性、互对称性、对称性、大O加法乘法结合律*

**用极限来分析：**

求
$$
lim_{n \to \infty}{\frac{T(n)}{g(n)}}
$$
结果有三种：

$$ \left\{ \begin{aligned} 0, &T(n)<g(n) \\ c>0, &T(n) = g(n) \\ \infty, &T(n)>g(n) \end{aligned} \right. $$

case1&2：$T(n) \in O(g(n))$

case2：$T(n) \in \Theta(g(n))$

csae2&3：$T(n) \in \Omega(g(n))$

算不出来可以用**洛必达法则**

**一些注意事项：**

所有对数函数都属于$\Theta(\log{n})$

所有多项式都属于$\Theta(n^k)$，$k$是多项式的次数

指数函数根据底数的不同，增长的速率不同。

### 2.4 常见的求和公式

$$
\sum_{i=l}^{u}(a^i \pm b^i) = \sum_{i=l}^{u}a^i \pm \sum_{i=l}^{u}b^i
$$

$$
\sum_{i=l}^{u}1 = u - l + 1
$$


$$
\sum_{i=0}^{n}i = \frac{n^2}{2} \in \Theta(n^2)
$$

### 2.5 实例

*汉诺塔，递归解法——*



```c
void hanoi(int n, int a, int b, int c){
	if(n>0)
		{
			hanoi(n-1,a,c,b);
			move(a,b);
			hanoi(n-1,b,a,c);
	}
}
```

其基本操作数为：

$C(n) = 2C(n-1) + 1 = 2^n-1$ 



*数十进制数的二进制形式有几位数字——*

```pseudocode
ALGORITHM BinRec(n)
	//Input: A positive decimal integer n
	//Output: The number of bin. digits in n's bin representation
	if n=1 return 1
	else return BinRec(floor(n/2)+1)
```

基本操作：$$+1$$的动作

解决这种递归的方法：令$n=2^k$，但是这种做法似乎忽略了许多个n的值。*Smoothness Rule*告诉我们这是ok的。

易知$A(n) = \log_2{n} = \Theta(\log{n})$

## 3. 暴力法

### 3.1 暴力法为什么要讲？

它给解决问题提供了一个下界。

对于这些问题，都可以用暴力法：

排序 - 选择排序、冒泡排序

穷举 - （哈密顿图）TSP问题、背包问题、分派工作：NP-Hard问题

## 4. 递归法

### 4.1 常见的递归法求解的问题

阶乘

斐波那契

汉诺塔问题

排列问题 

### 4.2 递归解法的类型

- Decrease-by-one

  $T(n) = T(n-1) + f(n)$

- Decrease-by-a-constant-factor

  $T(n) = aT(\frac{n}{b} + f(n))$

  ***The Master Theorem***

  $T(n)=aT(\frac{n}{b})+f(n)$, where $f(n) \in \Theta(n^k)$

  a. $a<b^k $, then $T(n) \in \Theta(n^k)$

  b. $a=b^k $, then $T(n) \in \Theta(n^k\log{n})$

  c. $a>b^k $, then $T(n) \in \Theta(n^{\log_b{a}})$



## 5. 分治法

### 5.1 怎样的问题适合分治法

原始问题的解可以规模均衡地分成相同类型的互相独立的最小问题地解，将后者做合并得到原始问题的解

