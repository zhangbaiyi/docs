# 《软件设计模式》学习心得

短短的半个学期，设计模式的学习结束了。侯捷先生的耐心讲解引人入胜，提供的实例也是语言底层的内容。对于设计模式，我起初感觉没什么作用，意义不大。但现在我却觉得处处都有设计模式，处处都必需设计模式。和同组的同学经历了两个月的艰苦奋斗，在大家的激烈讨论中，我也学习到了不少东西，特此整理成几个小部分加以总结。

## 工厂方法模式与抽象工厂模式辨析

在[这篇科普文章](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)中，作者介绍道“抽象工厂模式是围绕一个超级工厂创建其他工厂”，这样理解容易造成歧义，以为仅仅是一个抽象类做“抽象工厂”，其他具体工厂类继承实现该抽象工厂的部分函数。但阅读日本作家结城浩所著的《图解设计模式》后，才意识到了自己理解出了偏差。

工厂方法模式从模版方法模式中演变而来。模版方法中，在父类规定处理的流程，在子类中实现具体的处理。模版方法模式使用这样的规程去处理一件事情，但如果不是处理事情，而是生成一个实例，模版方法模式就变成了工厂方法模式。

在工厂方法模式中，父类决定实例的生成方式，不决定具体的要生成的类。具体处理全部交给子类负责。这样做的好处是，在工厂中可以不用`new`来生成实例，只用调用生成实例专用的方法来生成实例，这样做就可以使父类与其他的具体类解耦，给程序带来很强的拓展性。

而抽象工厂虽然名字中有“工厂”二字，但却和工厂方法大相径庭。抽象工厂的作用是将“抽象零件”组装为“抽象产品”。用网页的例子很好地能说明这个问题，假设现在要做一个网页，其中有链接和存放链接的容器这两种主要的组件。此时我可以用列表方式组织链接，也即将`List`作为上述的容器；也可以用表格方式`Table`作为上述的容器。在这个例子中，链接和容器还有最终的页面就是抽象零件，抽象的工厂只知道需要生成抽象的零件，具体这个零件怎样加入到容器中，就要让继承工厂类的具体类去处理了。

抽象工厂模式给增加具体的工厂提供了非常方便的接口，无论增加多少个工厂都不用修改抽象工厂类的代码，甚至都不用修改委托者类的调用函数（因为可以通过运行时参数指定具体工厂类选哪个）。可以说这个设计模式完美地体现了`OCP`原则。

## 访问者模式