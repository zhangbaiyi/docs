# 《软件设计模式》学习心得

短短的半个学期，设计模式的学习结束了。侯捷先生的耐心讲解引人入胜，提供的实例也是语言底层的内容。对于设计模式，我起初感觉没什么作用，意义不大。但现在我却觉得处处都有设计模式，处处都必需设计模式。和同组的同学经历了两个月的艰苦奋斗，在大家的激烈讨论中，我也学习到了不少东西，在此整理成几个小部分加以总结。

## 工厂方法模式与抽象工厂模式辨析

在[这篇科普文章](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)中，作者介绍道“抽象工厂模式是围绕一个超级工厂创建其他工厂”，这样理解容易造成歧义，以为仅仅是一个抽象类做“抽象工厂”，其他具体工厂类继承实现该抽象工厂的部分函数。但阅读日本作家结城浩所著的《图解设计模式》后，才意识到了自己理解出了偏差。

工厂方法模式从模版方法模式中演变而来。模版方法中，在父类规定处理的流程，在子类中实现具体的处理。模版方法模式使用这样的规程去处理一件事情，但如果不是处理事情，而是生成一个实例，模版方法模式就变成了工厂方法模式。

在工厂方法模式中，父类决定实例的生成方式，不决定具体的要生成的类。具体处理全部交给子类负责。这样做的好处是，在工厂中可以不用`new`来生成实例，只用调用生成实例专用的方法来生成实例，这样做就可以使父类与其他的具体类解耦，给程序带来很强的拓展性。

而抽象工厂虽然名字中有“工厂”二字，但却和工厂方法大相径庭。抽象工厂的作用是将“抽象零件”组装为“抽象产品”。用网页的例子很好地能说明这个问题，假设现在要做一个网页，其中有链接和存放链接的容器这两种主要的组件。此时我可以用列表方式组织链接，也即将`List`作为上述的容器；也可以用表格方式`Table`作为上述的容器。在这个例子中，链接和容器还有最终的页面就是抽象零件，抽象的工厂只知道需要生成抽象的零件，具体这个零件怎样加入到容器中，就要让继承工厂类的具体类去处理了。

抽象工厂模式给增加具体的工厂提供了非常方便的接口，无论增加多少个工厂都不用修改抽象工厂类的代码，甚至都不用修改委托者类的调用函数（因为可以通过运行时参数指定具体工厂类选哪个）。可以说这个设计模式完美地体现了`OCP`原则。

![](./assets/1-1.jpeg)

上图分别是模版方法模式、工厂方法模式、抽象工厂模式的类图，可以加强对于这三种设计模式的理解和辨析。

## 理解访问者模式的递归调用

访问者模式最初学的时候可以说是一头雾水。只知道它是和数据结构有关的一种模式，但看到`accept`方法和`visit`方法相互调用，还是不知道具体地发生了什么事情。

总结来讲，使用访问者模式一共有这么几个步骤。

1. 数据结构维护`accept`方法给访问者提供具体实例。让数据结构继承某个接口，实现能够接受访问者类做参数的`accept`方法，此处的`accept`方法，有一个`this`的*buff*，此时的`this`指向的是当前数据结构类中的某个实例所在的位置，进而在该`accept`方法中让访问者参数（也就是访问者实例）访问这个`this`，此时`this`又做了参数，访问者实例根据这个参数来决定访问这个实例时采用什么流程，这是下一个步骤中要说明的内容。
2. 访问者维护`visit`方法来明确对于具体实例采用怎样的操作。实现访问者类的`visit`方法。

